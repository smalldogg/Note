## java 并发机制的底层实现原理

### volatile的定义与实现原理

1. 保证可见性，不保证原子性
2. 禁止指令重排

### lock指令

1. 将当前处理器缓存行的数据写回到系统内存
2. 这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。  

### 缓存一致性协议

利用了总线嗅探机制来对缓存行进行更新

### volatile的实现原则

1. Lock前缀指令会引起处理器缓存回写到内存 
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存无效  

### synchronized  

java中每一个对象都可以作为锁

1. 对于普通同步方法，锁是当前实例对象。
2. 对于静态同步方法，锁是当前类的Class对象。
3. 对于同步方法块，锁是Synchonized括号里配置的对象  

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁  

代码块同步是使用monitorenter和monitorexit指令实现的  

### java对象头

![]()![对象头](D:\MyWork\MarkDownPicture\jvm\对象头.png)

### 锁升级的过程

锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁  

### 偏向锁

当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁  

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁  

### 轻量级锁  

线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针  