## 输入和输出映射  

我们知道mybatis中输入映射和输出映射可以是基本数据类型、hashmap或者pojo的包装类型，这里主要来总结一下pojo包装类型的使用，因为这个在开发中比较常用。

**1、输入映射**

   输入映射，是在映射文件中通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型。假设现在有个比较复杂的查询需求：完成用户信息的综合查询，需要传入查询条件很复杂（可能包括用户信息、其它信息，比如商品、订单的），那么我们单纯的传入一个User就不行了，所以首先我们得根据查询条件，自定义一个新的pojo，在这个pojo中包含所有的查询条件。

**1.1、定义包装类型pojo**

定义一个UserQueryVo类，将要查询的条件包装进去。这里为了简单起见，就不添加其他的查询条件了，UserQueryVo中就包含一个User，假设复杂的查询条件在User中都已经包含了。

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.mybatis.entity;

public class UserQueryVo {
    
    //在这里添加所需要的查询条件
    //用户查询条件，这里假设一个User就已经够了
    private User user;

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }   

    //可以包装其他的查询条件，比如订单、商品等
    //......    

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**1.2、配置UserMapper.xml文件**

定义好了我们自己的pojo后，需要在UserMapper.xml映射文件中配置查询的statement，如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```xml
<!-- 模拟包装类型组合查询 
     #{user.sex}:取出pojo包装对象中性别值
     ${user.username}：取出pojo对象中姓名值
-->
<select id="findUserList" parameterType="com.mybatis.entity.UserQueryVo" resultType="com.mybatis.entity.User">
    select * from t_user where sex = #{user.sex} and username like '%${user.username}%'
</select>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

　　我们看到，输入的parameterType的值是我们自己定义的pojo，输出的是User，当然这里的User也可以换成另一个用户自定义的pojo，包含用户所需要的条件，都行，不仅仅局限为User。然后查询条件使用OGNL表达式，取出UserQueryVo中User的相应属性即可。

**1.3、UserMapper.java类的代码**

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.mybatis.mapper;

import java.util.List;

import com.mybatis.entity.User;
import com.mybatis.entity.UserQueryVo;

/**
 * 用户管理mapper接口
 * @author lixiaoxi
 * 2017-02-06
 */
public interface UserMapper {
    
    //用户信息综合查询
    public List<User> findUserList(UserQueryVo userQueryVo);

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**1.4、JUnit单元测试代码**

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.mybatis.test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Before;
import org.junit.Test;

import com.mybatis.entity.User;
import com.mybatis.entity.UserQueryVo;
import com.mybatis.mapper.UserMapper;

public class UserMapperTest {

    private SqlSessionFactory sqlSessionFactory;

    // 此方法是在执行@Test标注的方法之前执行
    @Before
    public void setUp() throws Exception {
        String resource = "SqlMapConfig.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 创建SqlSessionFcatory
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    
    @Test
    public void testFindUserList() {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //创建包装对象，设置查询条件
         UserQueryVo userQueryVo = new UserQueryVo();
        User user = new User();
        user.setSex("1");
        user.setUsername("小");
        userQueryVo.setUser(user);
        // 创建UserMapper对象，mybatis自动生成mapper代理对象
         UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List<User>list=mapper.findUserList(userQueryVo);
        System.out.println(list);
        sqlSession.commit();
        sqlSession.close();
    }

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**2、输出映射**

**2.1、resultType**

   使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象。
只要查询出来的列名和pojo中的属性有一个一致，就会创建pojo对象。

**2.1.1、输出简单类型**

需求：用户信息的综合查询列表，通过查询总数才能实现分页功能。

UserMapper.xml的代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace命名空间,作用就是对sql进行分类化的管理,理解为sql隔离
    注意:使用mapper代理开发时，namespace有特殊作用,namespace等于mapper接口地址
 -->
<mapper namespace="com.mybatis.mapper.UserMapper">
    
    <!-- 用户信息综合查询总数
         parameterType:指定输入类型，和findUserList一致。
         resultType:输出结果类型.    
      -->
    <select id="findUserCount" parameterType="com.mybatis.entity.UserQueryVo" resultType="int">
        select count(*) from t_user where  sex=#{user.sex} and username like '%${user.username}%'
    </select>
    
</mapper>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

UserMapper.java的代码：

```java
public interface UserMapper {

    //用户信息综合查询总数
    public int findUserCount(UserQueryVo userQueryVo);

}
```

JUnit测试代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.mybatis.test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Before;
import org.junit.Test;

import com.mybatis.entity.User;
import com.mybatis.entity.UserQueryVo;
import com.mybatis.mapper.UserMapper;

public class UserMapperTest {

    private SqlSessionFactory sqlSessionFactory;

    // 此方法是在执行@Test标注的方法之前执行
    @Before
    public void setUp() throws Exception {
        String resource = "SqlMapConfig.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 创建SqlSessionFcatory
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    
    @Test
    public void findUserCountTest() {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        //创造查询条件
         UserQueryVo userQueryVo = new UserQueryVo();
        User user = new User();
        user.setSex("1");
        user.setUsername("小");
        userQueryVo.setUser(user);
        // 创建UserMapper对象，mybatis自动生成mapper代理对象
         UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int count=mapper.findUserCount(userQueryVo);
        System.out.println(count);
        sqlSession.commit();
        sqlSession.close();
    }

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**小结:查询出来的结果集只有一行一列，可以使用简单类型进行输出映射。**

**2.1.2、输出pojo对象和pojo列表**

**不管是输出的pojo单个对象还是一个列表（list中包括pojo），在mapper.xml中resultType指定的类型是一样的。但在mapper.java指定的方法返回值类型不一样。**

**输出单个pojo对象，方法返回值是单个对象类型**

```java
public interface UserMapper {
    
    /** 根据ID查询用户信息 */
    public User findUserById(int id);
}
```

**输出pojo对象list，方法返回值是List<pojo>**

```java
public interface UserMapper {

    /** 根据用户名称模糊查询用户信息 */
    public List<User> findUserByName(String username);
}
```

**小结：生成的动态代理对象中是根据mapper.java方法的返回值类型确定是调用selectOne(返回单个对象调用)还是selectList(返回集合对象调用)**

**2.2、resultMap**

   我们知道，通过resultType输出映射的时候，查询出来的列名和pojo中对应的属性名要一致才可以做正确的映射，如果不一致就会映射错误。但是如果不一致呢？该如何解决这个问题呢？这就要使用resultMap来映射了。
   假设现在映射文件中有个sql语句：select id id_,username username_ from t_user where id=#{id}，从这个sql语句中可以看出，查询出了id和username两列，但是都起了别名了，也就是说，如果我们现在用resultType去映射到User中的话，肯定会出问题，所以我们现在要定义一个resultMap来做查询结果列与User的属性之间的一个映射。

**2.2.1、resultMap使用方法**
(1).定义resultMap
(2).使用resultMap作为statement的输出映射类型

**2.2.2、demo例子**

(1).需求：将下面的sql使用resultMap完成映射

select id id_,username username_ from t_user where id=?

User类中属性名和上边的列名不一致。

(2).在SqlMapConfig.xml中自定义别名

```xml
<!-- 批量别名的定义:
    package:指定包名，mybatis会自动扫描包中的pojo类，自动定义别名，别名就是类名(首字母大写或小写都可以)
 -->
 <typeAliases>
     <package name="com.mybatis.entity"/>
</typeAliases>
```

(3).定义resultMap

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!-- namespace命名空间,作用就是对sql进行分类化的管理,理解为sql隔离
    注意:使用mapper代理开发时，namespace有特殊作用,namespace等于mapper接口地址
 -->
<mapper namespace="com.mybatis.mapper.UserMapper">
    
    <!-- 定义resultMap 
     select id id_,username username_ from t_user和User类中的属性作为一个映射关系
     type:resultMap最终映射的java对象类型，可以使用别名；
     id:对resultMap的唯一标识
     -->
     <resultMap type="user" id="userResultMap">
         <!--id表示查询结果中的唯一标识，
             column：查询出来的列名
             property：type指定的pojo类型中的属性名
             最终resultMap对column和property作一个映射关系（对应关系）
          -->
         <id column="id_" property="id"/>
         <!--result:表示对普通列名的映射，
            column：查询出来的列名
            property：type指定的pojo类型中的属性名
            最终resultMap对column和property作一个映射关系（对应关系）
           -->
         <result column="username_" property="username"/>
    </resultMap> 
    
</mapper>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

(4).使用resultMap作为statement的输出类型映射

```xml
<!-- 使用resultMap作为输出映射
    resultMap:指定定义的resultMap的id，如果这个resultMap在其它的mapper.xml文件中，前边需要添加namespace命名空间
-->
<select id="findUserByIdResultMap" parameterType="int" resultMap="userResultMap" >
    select id id_,username username_ from t_user where id=#{id}
</select>
```

(5).UserMapper.java代码：

```java
public interface UserMapper {
    
    /** 根据ID查询用户信息,使用resultMap进行输出 */
    public User findUserByIdResultMap(int id);
}
```

(6).JUnit测试代码：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
package com.mybatis.test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Before;
import org.junit.Test;

import com.mybatis.entity.User;
import com.mybatis.entity.UserQueryVo;
import com.mybatis.mapper.UserMapper;

public class UserMapperTest {

    private SqlSessionFactory sqlSessionFactory;

    // 此方法是在执行@Test标注的方法之前执行
    @Before
    public void setUp() throws Exception {
        String resource = "SqlMapConfig.xml";
        InputStream inputStream = Resources.getResourceAsStream(resource);
        // 创建SqlSessionFcatory
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    }
    
    @Test
    public void testFindUserByIdResultMap() {
        SqlSession sqlSession = sqlSessionFactory.openSession();
        // 创建Usermapper对象，mybatis自动生成mapper代理对象
         UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User user = mapper.findUserByIdResultMap(1);
        System.out.println(user);
        sqlSession.close();
    }

}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

**3、小结：**
用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。
如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系。