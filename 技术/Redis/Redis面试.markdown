## 网络与IO



![](D:\MyWork\MarkDownPicture\io\io模型.png)

## 使用（参考processon）

## redis  rehash

1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。

### 负载因子

usesd[0]/



## redis在你项目中的使用场景

```
1，5大value类型：根据我的redis课有场景的介绍
2，基本上就是缓存~！
3，为的是服务无状态，延申思考，看你的项目有哪些数据结构或对象，在单机里需要单机锁，在多机需要分布式锁，抽出来放入redis中；
4，无锁化
```

## 缓存穿透

redis工作线程是串行化的，那么即便第一线程去更新了缓存，之后的也还是会继续请求数据库

数据库和缓存都没有这部分数据

可以缓存一个 key为null,但是遇到爬虫这种东西，那么还是会给你插入很多的空key 

或者可以由redis提供锁，

1，请求redis，那么肯定是没有的，此时抢锁

2，抢到锁的去查数据库

3，没抢到的去sleep

4， db，更新redis

5，sleep的线程会到第一步

## 缓存击穿（热点key过期）

参考穿透

## 雪崩

1，过期事件加随机时间

2，参考上面的模型

锁肯定是排他的，必须由一个redis提供

当key很多的时候。，那么就可以akf分支

每一个key的锁的隔离的

锁可以分片，提供扩展能力

这里key很多，很散碎，sleep是分摊的



## redis是怎么删除过期的key的

- **noeviction**:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
- **allkeys-lru**: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
- **volatile-lru**: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
- **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。
- **volatile-random**: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
- **volatile-ttl**: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

### 回收进程是如何工作的

1，后台轮询

2，惰性删除



## 缓存和数据库一致

1，可以使用分布式事务来解决，但是需要考虑收益

2，redis是缓存，更倾向于有稍微的时差

3，真正落地的话，使用canal

## redis主从不一致问题

1，redis默认是弱一致性

2，锁不能主从（需要单实例，redlock）

3，在配置中提供了多少个client连接能同步，趋向于强一致性

## redis主从

1，slaveof本身是异步命令。后续复制流程在节点内部是异步执行的

### 拓扑

1，一主一从

可以关闭主的aof日志，保证性能，但是需要注意的是当主发生故障，需要在从执行slaveof on one的操作

2，一主多从



3，树状结构