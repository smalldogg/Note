## osi七层模型

![](D:\MyWork\MarkDownPicture\network\osi.png)_



### 应用层

只关心业务逻辑，不关心数据的传输

### 表示层

负责协商用于传输的数据格式

### 会话层

负责管理两个连网实体间的连接

功能及特点：建立连接，维持通信，释放连接

### 传输层

负责**将数据从一个实体**(一个服务或应用)传输到另一个实体，但不负责数据传输的方式。

相当于快递公司

**数据分隔重组：**将数据拆分后按顺序重组

**纠错：**在数据传输过程中出现问题后采取方式进行纠正

**管理连接：**处理数据的频繁交换

**流量控制：**控制传输数据的速率

**端口寻址：**标明参与传输的实体的端口号

### 网络层

负责把一个封包从一个ip地址传输到另一个ip地址

路由算法

### 数据链路层

相邻设备间的传输，并隐藏底层实现

1. 帧同步

2. 数据纠错

### 物理层

## tcp协议 传输层协议

![](D:\MyWork\MarkDownPicture\network\tcp_ip.png)

## tcp协议详解

1. 建立连接

   ![](D:\MyWork\MarkDownPicture\network\三次握手.png)

![](D:\MyWork\MarkDownPicture\network\四次挥手.png)

### 传输数据

1. 报文拆分
2. 增加tcp头
3. 数据重组

当应用层数据很大时，需要对数据进行拆分

![](D:\MyWork\MarkDownPicture\network\数据拆分.png)

我们需要在接收端进行重组，这里就需要保证顺序

![](D:\MyWork\MarkDownPicture\network\tcp序号.png)

### 纠错和checksum

lTCP拥有一个**16bit**的Checksum字段

lChecksum是一个**函数**，**把原文映射到一个不可逆的16bit的编码**中这样就可以**知道原文传输过程中有没有发生变化**

### 流控能力

主要目标：让发送方和接收方协商一个**合理的收发速率**，让两边都可以**稳定**的工作。

利用**滑动窗口**

## tcp和udp的区别

1. 连接
   TCP 是面向连接的传输层协议，传输数据前先要建立连接。
   UDP 是不需要连接，即刻传输数据。
2. 服务对象
   TCP 是一对一的两点服务，即一条连接只有两个端点。
   UDP 支持一对一、一对多、多对多的交互通信
3. 可靠性
   TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
   UDP 是尽最大努力交付，不保证可靠交付数据。  

4. 拥塞控制、流量控制
   TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。
   UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。  

5. 首部开销
   TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用
   了「选项」字段则会变长的。
   UDP 首部只有 8 个字节，并且是固定不变的，开销较小  

![](D:\MyWork\MarkDownPicture\network\tcp&udp.png)

## tcp连接建立





## IP协议（网络层协议）

需要解决的三个问题

### 延迟

### 吞吐量

### 丢包率

ip协议的工作过程

![](D:\MyWork\MarkDownPicture\network\ip工作过程.png)

### ip协议头

**Type Of Service**：服务的类型，是为了响应不同的用户诉求，用来选择延迟、吞吐量和丢包率之间的关系。

**IHL（Internet Header Length)**：IP协议头的大小。

**Total Length**：报文(封包datagram)的长度

**Identification**：报文的ID，发送方分配，代表顺序

**Fragment offset**：描述是否要分包（拆分），和如何拆分。

**Time To Live**：封包存活的时间。

**Protocol**：描述上层的协议，比如TCP=6,UDP=17

**Options**：可选项

**Checksum**：检验封包的正确性



## 对称加密和非对称加密

对称加密：加密/解密用**一个秘钥**，且加密方和解密方**都知道秘钥**，如DES,3DES等。

非对称加密：加密用一个秘钥，解密用**另一个秘钥**且加密方一般有2个秘钥，解密方有一个解密秘钥。非对称加密安全性高，但速度慢，如RSA算法。

## 摘要算法

摘要算法：就是将原文和摘要同时传输给接收方。

## 权威机构证书

![](D:\MyWork\MarkDownPicture\network\证书.png)

## 信任链条

## https

![](D:\MyWork\MarkDownPicture\network\https.png)

https采用对称加密的方式加密传输的数据，然后对称加密的密钥，采用非对称加密的方式就行协商

![](D:\MyWork\MarkDownPicture\network\https过程.png)

https的证书是通过信任链来完成的





## 图解



![面试突击班-网络和IO面试题](E:\MSB\突击班面经\面试突击班3.13网络和IO\面试突击班-网络和IO面试题.jpg)

1. 三次握手和四次挥手是发生在内核空间

   1. 第三次握手是可以携带数据的，前两次握手时不可以携带数据的

   2. 为什么需要三次握手

      1. 三次握手可以阻止历史重复连接的初始化

         在旧的syn比新的syn先来的时候，客户端通过比较发现这不是自己期望收到的，会发出rest报文中止协议

      2. 所以可以防止历史连接初始化连接

      3. 避免资源的浪费

   3. 为什么需要四次挥手

      1. 服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送fin给客户端

   4. 为什么需要Time_Wait

      1. 保证正确关闭
      2. 保证具有相同四元组旧数据包被收到（避免数据发生错乱）

## tcp如何保证可靠

1. 超时重传，滑动窗口，流量控制，拥塞控制
2. 窗口的大小由接收方确定